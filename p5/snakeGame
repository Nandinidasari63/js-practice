
const CELL = 20;
const BOX = { x: 100, y: 100, w: 500, h: 500 };
const FPS = 6;
//game state
let state;
let osc, env;

// SETUP
function setup() {
  createCanvas(700, 700);
  frameRate(FPS);

  osc = new p5.Oscillator("triangle");
  env = new p5.Envelope();
  env.setADSR(0.01, 0.1, 0, 0.05);
  env.setRange(0.5, 0);
  osc.start();
  osc.amp(env);

  initGame();
}

function initGame() {
  state = {
    status: "RUNNING",
    direction: { x: 1, y: 0 },
    requestedDirection: null,
    snake: [{ x: 10, y: 10 }],
    food: randomFood(),
    score: 0
  };
}

//loop
function draw() {
  background(220);

  if (state.status === "RUNNING") {
    updateGame();
  }

  renderGame();
}

//directions
function keyPressed() {
  const map = {
    [UP_ARROW]: { x: 0, y: -1 },
    [DOWN_ARROW]: { x: 0, y: 1 },
    [LEFT_ARROW]: { x: -1, y: 0 },
    [RIGHT_ARROW]: { x: 1, y: 0 }
  };

  if (map[keyCode]) {
    state.requestedDirection = map[keyCode];
  }
}

// update logic
function updateGame() {
  applyDirection();

  const head = state.snake[0];
  const nextHead = {
    x: head.x + state.direction.x,
    y: head.y + state.direction.y
  };

  if (hitsWall(nextHead) || hitsSelf(nextHead)) {
    playBeep(1500);
    state.status = "GAME_OVER";
    noLoop();
    return;
  }

  state.snake.unshift(nextHead);

  if (eatsFood(nextHead)) {
    playBeep(700);
    state.food = randomFood();
    state.score++;
  } else {
    state.snake.pop();
  }
}

//validating direction
function applyDirection() {
  if (!state.requestedDirection) return;

  const d = state.direction;
  const r = state.requestedDirection;

  // block reverse
  if (d.x + r.x === 0 && d.y + r.y === 0) return;

  state.direction = r;
  state.requestedDirection = null;
}

//collision logics both hitsWall and hitsSelf
function hitsWall(pos) {
  const min = BOX.x / CELL;
  const max = min + BOX.w / CELL - 1;
  return pos.x < min || pos.x > max || pos.y < min || pos.y > max;
}

function hitsSelf(pos) {
  return state.snake.some(seg => seg.x === pos.x && seg.y === pos.y);
}

function eatsFood(pos) {
  return pos.x === state.food.x && pos.y === state.food.y;
}

function randomFood() {
  const min = BOX.x / CELL;
  const max = min + BOX.w / CELL;
  return {
    x: floor(random(min, max)),
    y: floor(random(min, max))
  };
}


// RENDERING (just drawing,no logic)

function renderGame() {
  stroke(0);
  strokeWeight(3);
  noFill();
  rect(BOX.x, BOX.y, BOX.w, BOX.h);

  noStroke();
  fill("black");
  for (const s of state.snake) {
   circle(
  s.x * CELL + CELL / 2,
  s.y * CELL + CELL / 2,
  CELL
);

  }

  fill("purple");
 square(state.food.x * CELL, state.food.y * CELL, CELL);


  fill("tomato");
  textSize(20);
  text("Score: " + state.score, 550, 50);

  if (state.status === "GAME_OVER") {
    textSize(32);
    text("GAME OVER", 260, 60);
    text("SCORE:"+state.score,260,100)
  }
}

function playBeep(freq) {
  osc.freq(freq);
  env.play();
}
